 <h1 align = "center">点云常用去噪声方法</h1>

PCL中总结了几种需要进行点云滤波处理的情况，如下：

1. 点云数据密度不规则需要平滑
2. 因遮挡等问题噪声的离群点需要去除
3. 数据冗余需要下采样
4. 噪声数据需要去除

对应的方法如下：

1. 按具体给定的规则过滤点
2. 通过滤波算法修改点的部分属性
3. 点云数据下采样

[代码框架](https://github.com/Aviana-Zheng/pcl_filter)



# 0、基础知识

## 0.1 格网

### 0.1.1 二维格网

三维激光扫描系统获取的点云数据通常是杂乱无章的，点与点之间没有明显的拓扑关系。建立点云的二维格网是一种简单有效且常用的点云索引方法。

所谓点云二维格网，就是将点云投影到某一个平面，然后用固定大小的的均匀网格对投影点云进行空间划分，其中，将点云投影到水平面进行二维格网化最为常见。

|       二维行列索引       |         一维索引         |
| :----------------------: | :----------------------: |
| ![](assets/grid2d-1.png) | ![](assets/grid2d-2.png) |

#### 0.1.1.2 二维格网的建立

以建立xoy平面二维格网为例，步骤如下：

1. 统计x坐标、y坐标的最值x<sub>min</sub>、y<sub>min</sub>、x<sub>max</sub>、y<sub>max</sub>，为方便后续的格网计算（比如格网八邻域搜索），通常在坐标最值的基础上添加一个缓冲距离δ，则
   $$
   \begin{cases}
      x_{min}  = x_{min} - δ\\
      y_{min}  = y_{min} - δ\\
      x_{max}  = x_{max} + δ\\
      y_{max}  = y_{max} + δ
     \end{cases}
   $$
   
2. 设置正方形格网边长step，则水平格网的行数row和列数col为
   $$
   \begin{cases}
      row  = int
      \left[
      \frac{y_{max} - y_{min}}{step}
      \right] + 1\\
      col  = int
      \left[
      \frac{x_{max} - x_{min}}{step}
      \right] + 1\\
     \end{cases}
   $$
   
   
   
3. 根据点的xoy平面坐标(x<sub>i</sub>，y<sub>i</sub>)，可以确定每一个点的行列号(r<sub>i</sub>，c<sub>i</sub>)，格网行列号从(1,1)开始
   $$
   \begin{cases}
   r_i = int
   \left[
   \frac{y_i - y_{min}}{step}
   \right] + 1 \\
   c_i = int
   \left[
   \frac{x_i - x_{min}}{step}
   \right] + 1
   \end{cases}
   $$
   
4. 根据每一点的行列号(r<sub>i</sub>，c<sub>i</sub>)，可确定每一点的一维格网索引g<sub>i</sub>，从1开始编号
   $$
   g_i = (r_i - 1) * col + c_i
   $$
   
   
   

#### 0.1.1.3 代码实现

以建立xoy平面格网为例，进行点云二维格网化。代码分为三部分：

+ main.cpp
+ grid2D.h
+ grid2D.cpp

<font color = red>`main.cpp`</font>

```c++
#include "grid2D.h"

int main()
{
	//----------------------------- 加载点云 -----------------------------
	pcl::PointCloud<PointT>::Ptr cloud_in(new pcl::PointCloud<PointT>);
	if (pcl::io::loadPCDFile("grid.pcd", *cloud_in) < 0)
	{
		PCL_ERROR("\a->点云文件不存在！\n");
		system("pause");
		abort();
	}
	cout << "->共加载 " << cloud_in->points.size() << " 个数据点" << endl;
	//===================================================================

	//-------------------------- 二维格网化点云 --------------------------
	Grid2DCreator g2c;				//创建二维格网化点云对象
	g2c.setInputCloud(cloud_in);	//设置输入点云
	g2c.setGridStep(0.05);			//设置格网边长
	g2c.setBuffer(0.05);			//设置缓冲区大小
	g2c.grid2D();					//执行二维格网化
	vector<int> rc;					//存放格网总行列数
	rc = g2c.getRowCol();			//获取格网总行列数
	cout << "->格网总行数：" << rc[0] << endl;
	cout << "->格网总列数：" << rc[1] << endl;
	//===================================================================

	return 0;
}
```

输出结果：

```shell
->共加载 5746 个数据点
->格网总行数：68
->格网总列数：65
```



<font color = red>`grid2D.h`</font>

```c++
#pragma once
#include <pcl/io/pcd_io.h>
#include <pcl\common\common.h>

using namespace std;
typedef pcl::PointXYZ PointT;

//二维格网类
class Grid2DCreator
{
public:
	/**
	* @brief   ：设置输入点云
	* @param[I]：cloud_in（输入点云）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setInputCloud(pcl::PointCloud<PointT>::Ptr cloud_in);

	/**
	* @brief   ：设置格网边长
	* @param[I]：step（格网边长）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setGridStep(double step);

	/**
	* @brief   ：设置缓冲区大小
	* @param[I]：buffer（缓冲区大小）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setBuffer(double buffer);

	/**
	* @brief   ：二维格网化
	* @param[I]：none
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void grid2D();

	/**
	* @brief   ：获取总行列数
	* @param[I]：none
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	vector<int> getRowCol();

private:
	pcl::PointCloud<PointT>::Ptr m_cloud_in;	//输入点云
	bool is_setInputCloud = false;

	double m_step;		//格网边长
	bool is_setGridStep = false;

	double m_buffer;	//缓冲区大小
	bool is_setBuffer = false;

	int m_row;			//格网总行数
	int m_col;			//格网总列数

};
```

<font color = red>`grid2D.cpp`</font>

```c++
#include "grid2D.h"

/**
* @brief   ：设置输入点云
* @param[I]：cloud_in（输入点云）
* @param[O]：none
* @return  : none
* @note    ：
**/
void Grid2DCreator::setInputCloud(pcl::PointCloud<PointT>::Ptr cloud_in)
{
	m_cloud_in = cloud_in;
	is_setInputCloud = true;
}

/**
* @brief   ：设置格网边长
* @param[I]：step（格网边长）
* @param[O]：none
* @return  : none
* @note    ：
**/
void Grid2DCreator::setGridStep(double step)
{
	if (step > 0)
	{
		m_step = step;
		is_setGridStep = true;
	}
	else
	{
		PCL_ERROR("\a->格网边长应为正数！\n");
		system("pause");
		abort();
	}
}
/**
* @brief   ：设置缓冲区大小，通常与格网边长一致
* @param[I]：buffer（缓冲区大小）
* @param[O]：none
* @return  : none
* @note    ：
**/
void Grid2DCreator::setBuffer(double buffer)
{
	if (buffer >= 0)
	{
		m_buffer = buffer;
		is_setBuffer = true;
	}
	else
	{
		PCL_ERROR("\a->缓冲区大小应为非负数！\n");
		system("pause");
		abort();
	}
}

/**
* @brief   ：二维格网化
* @param[I]：none
* @param[O]：none
* @return  : none
* @note    ：
**/
void Grid2DCreator::grid2D()
{
	if (!is_setGridStep)
	{
		PCL_ERROR("\a->请先设置格网边长！\n");
		system("pause");
		abort();
	}
	pcl::PointXYZ min;
	pcl::PointXYZ max;
	pcl::getMinMax3D(*m_cloud_in, min, max);

	//添加缓冲区
	if (is_setBuffer)
	{
		min.x -= m_buffer;
		min.y -= m_buffer;
		max.x += m_buffer;
		max.y += m_buffer;
	}

	m_row = (int)((max.y - min.y) / m_step) + 1;
	m_col = (int)((max.x - min.x) / m_step) + 1;

	int row_i;			//每一点的行号，从1开始
	int col_i;			//每一点的列号，从1开始
	int grid_id_pt;		//逐行对应的一维格网编号id，从1开始
	multimap<int, PointT> m_grid2D;	//存放水平面格网点云的容器

	//遍历点云，进行二维格网化
	size_t num_cp = m_cloud_in->points.size();
	for (size_t i = 0; i < num_cp; i++)
	{
		row_i = (int)((m_cloud_in->points[i].y - min.y) / m_step) + 1;	//每一点的行号，从1开始
		col_i = (int)((m_cloud_in->points[i].x - min.x) / m_step) + 1;	//每一点的列号，从1开始

		grid_id_pt = (row_i - 1) * m_col + col_i;						//格网一维索引，从1开始
		m_grid2D.insert(pair<int, PointT>(grid_id_pt, m_cloud_in->points[i]));	//将每一个id对应的点坐标存入容器grids2D中
	}
}

/**
* @brief   ：获取总行列数
* @param[I]：none
* @param[O]：none
* @return  : rc（格网总行列数）
* @note    ：
**/
vector<int> Grid2DCreator::getRowCol()
{
	vector<int> rc;		//存放格网总行列数
	rc.push_back(m_row);
	rc.push_back(m_col);
	return rc;
}
```



### 0.1.2 三维格网

三维体素格网在二维格网的基础上，增加一维“层数”。

![](assets/grid3d.png)

#### 0.1.2.1 三维体素格网的建立

1. 统计x坐标、y坐标、z坐标的最值x<sub>min</sub>、y<sub>min</sub>、z<sub>min</sub>、x<sub>max</sub>、y<sub>max</sub>、z<sub>max</sub>，为方便后续的格网计算（比如格网邻域搜索），通常在坐标最值的基础上添加一个缓冲距离δ，则
   $$
   \begin{cases}
      x_{min}  = x_{min} - δ\\
      y_{min}  = y_{min} - δ\\
      z_{min}  = z_{min} - δ\\
      x_{max}  = x_{max} + δ\\
      y_{max}  = y_{max} + δ\\
      z_{max}  = z_{max} + δ
     \end{cases}
   $$
   
2. 设置体素格网边长为step，则行数row、列数col和层数lay分别为
   $$
   \begin{cases}
      row  = int
      \left[
      \frac{y_{max} - y_{min}}{step}
      \right] + 1\\
      col  = int
      \left[
      \frac{x_{max} - x_{min}}{step}
      \right] + 1\\
      lay = int
      \left[
      \frac{z_{max} - z_{min}}{step}
      \right] + 1
     \end{cases}
   $$
   
   
   
3. 根据点的坐标(x<sub>i</sub>，y<sub>i</sub>, z<sub>i</sub>)，可以确定每一个点的行列层号(r<sub>i</sub>，c<sub>i</sub>，l<sub>i</sub>)，格网行列层号从(1，1，1)开始
   $$
   \begin{cases}
   r_i = int
   \left[
   \frac{y_i - y_{min}}{step}
   \right] + 1 \\
   c_i = int
   \left[
   \frac{x_i - x_{min}}{step}
   \right] + 1 \\
   l_i = int
   \left[
   \frac{z_i - z_{min}}{step}
   \right] + 1
   \end{cases}\\
   $$
   
4. 根据每一点的行列层号(r<sub>i</sub>，c<sub>i</sub>，l<sub>i</sub>)，可确定每一点的一维格网索引g<sub>i</sub>，从1开始编号
   $$
   g_i = (l_i - 1) * (row * col) + (r_i - 1) * col + c_i
   $$
   

#### 0.1.2.2 代码实现

代码包含三部分：

+ main.cpp
+ grid3D.h
+ grid3D.cpp

<font color = red>`main.cpp`</font>

```c++
#include "grid3D.h"

int main()
{
	//----------------------------- 加载点云 -----------------------------
	pcl::PointCloud<PointT>::Ptr cloud_in(new pcl::PointCloud<PointT>);
	if (pcl::io::loadPCDFile("grid.pcd", *cloud_in) < 0)
	{
		PCL_ERROR("\a->点云文件不存在！\n");
		system("pause");
		abort();
	}
	cout << "->共加载 " << cloud_in->points.size() << " 个数据点" << endl;
	//===================================================================

	//------------------------- 三维体素格网化点云 ------------------------
	Grid3DCreator g3c;				//创建三维体素格网化对象
	g3c.setInputCloud(cloud_in);	//设置输入点云
	g3c.setGridStep(0.05);			//设置体素格网边长
	g3c.setBuffer(0.05);			//设置缓冲区大小
	g3c.grid3D();					//执行三维体素格网化
	vector<int> rcl;				//存放格网总行列层数
	rcl = g3c.getRowColLay();		//获取格网总行列层数

	cout << "->格网总行数：" << rcl[0] << endl;
	cout << "->格网总列数：" << rcl[1] << endl;
	cout << "->格网总层数：" << rcl[2] << endl;
	//===================================================================

	return 0;
}
```



输出结果：

```shell
->共加载 5746 个数据点
->格网总行数：68
->格网总列数：65
->格网总层数：140
```

<font color = red> `grid3D.h`</font>

```c++
#pragma once
#include <pcl/io/pcd_io.h>
#include <pcl/common/common.h>

using namespace std;

typedef pcl::PointXYZ PointT;

//点云三维体素格网化
class Grid3DCreator
{
public:
	/**
	* @brief   ：设置输入点云
	* @param[I]：cloud_in（输入点云）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setInputCloud(pcl::PointCloud<PointT>::Ptr cloud_in);

	/**
	* @brief   ：设置体素格网边长
	* @param[I]：step（体素格网边长）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setGridStep(double step);

	/**
	* @brief   ：设置缓冲区大小
	* @param[I]：buffer（缓冲区大小）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setBuffer(double buffer);

	/**
	* @brief   ：三维体素格网化
	* @param[I]：none
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void grid3D();

	/**
	* @brief   ：获取总行列层数
	* @param[I]：none
	* @param[O]：none
	* @return  : vector<int>(3)，行列层数
	* @note    ：
	**/
	vector<int> getRowColLay();
	

private:
	pcl::PointCloud<PointT>::Ptr m_cloud_in;	//输入点云
	bool is_setInputCloud = false;

	double m_step;		//格网边长
	bool is_setGridStep = false;

	double m_buffer;	//缓冲区大小
	bool is_setBuffer = false;

	int m_row;			//格网总行数
	int m_col;			//格网总列数
	int m_lay;			//格网总层数
	
};
```

<font color = red> `grid3D.cpp`</font>

```c++
#include "grid3D.h"

/**
* @brief   ：设置输入点云
* @param[I]：cloud_in（输入点云）
* @param[O]：none
* @return  : none
* @note    ：
**/
void Grid3DCreator::setInputCloud(pcl::PointCloud<PointT>::Ptr cloud_in)
{
	m_cloud_in = cloud_in;
	is_setInputCloud = true;
}

/**
* @brief   ：设置体素格网边长
* @param[I]：step（体素格网边长）
* @param[O]：none
* @return  : none
* @note    ：
**/
void Grid3DCreator::setGridStep(double step)
{
	if (step > 0)
	{
		m_step = step;
		is_setGridStep = true;
	}
	else
	{
		PCL_ERROR("\a->格网边长应为正数！\n");
		system("pause");
		abort();
	}
}

/**
* @brief   ：设置缓冲区大小
* @param[I]：buffer（缓冲区大小）
* @param[O]：none
* @return  : none
* @note    ：
**/
void Grid3DCreator::setBuffer(double buffer)
{
	if (buffer >= 0)
	{
		m_buffer = buffer;
		is_setBuffer = true;
	}
	else
	{
		PCL_ERROR("\a->缓冲区大小应为非负数！\n");
		system("pause");
		abort();
	}
}

/**
* @brief   ：三维体素格网化
* @param[I]：none
* @param[O]：none
* @return  : none
* @note    ：
**/
void Grid3DCreator::grid3D()
{
	if (!is_setGridStep)
	{
		PCL_ERROR("\a->请先设置格网边长！\n");
		system("pause");
		abort();
	}
	pcl::PointXYZ min;
	pcl::PointXYZ max;
	pcl::getMinMax3D(*m_cloud_in, min, max);

	//添加缓冲区
	if (is_setBuffer)
	{
		min.x -= m_buffer;
		min.y -= m_buffer;
		min.z -= m_buffer;
		max.x += m_buffer;
		max.y += m_buffer;
		max.z += m_buffer;
	}
	
	m_row = (int)((max.y - min.y) / m_step) + 1;
	m_col = (int)((max.x - min.x) / m_step) + 1;
	m_lay = (int)((max.z - min.z) / m_step) + 1;

	int row_i;			//每一点的行号，从1开始
	int col_i;			//每一点的列号，从1开始
	int lay_i;		//每一点的层号，从1开始
	int grid_id_pt;		//逐行对应的一维格网编号id，从1开始
	multimap<int, PointT> m_grid3D;	//存放水平面格网点云的容器
	
	//遍历点云，进行三维体素格网化
	size_t num_cp = m_cloud_in->points.size();
	for (size_t i = 0; i < num_cp; i++)
	{
		row_i = (int)((m_cloud_in->points[i].y - min.y) / m_step) + 1;	//每一点的行号，从1开始
		col_i = (int)((m_cloud_in->points[i].x - min.x) / m_step) + 1;	//每一点的列号，从1开始
		lay_i = (int)((m_cloud_in->points[i].z - min.z) / m_step) + 1;//每一点的列号，从1开始

		grid_id_pt = (lay_i - 1) * (m_row * m_col) + (row_i - 1) * m_col + col_i;	//格网一维索引，从1开始
		m_grid3D.insert(pair<int, PointT>(grid_id_pt, m_cloud_in->points[i]));		//将每一个id对应的点坐标存入容器grids3D中
	}
	
}

/**
* @brief   ：获取总行列层数
* @param[I]：none
* @param[O]：none
* @return  : vector<int>(3)，行列层数
* @note    ：
**/
vector<int> Grid3DCreator::getRowColLay()
{
	vector<int>rcl;		//体素格网总行列层数
	rcl.push_back(m_row);
	rcl.push_back(m_col);
	rcl.push_back(m_lay);

	return rcl;
}
```





# 1、点云上采样与下采样(数据放大与压缩)

放大图像（或称为上采样（`upsampling`）或图像插值（`interpolating`））的主要目的是放大原图像,从而可以显示在更高分辨率的显示设备上。

上采样（`upsampling`）的实现，容易想到三种方式，分别对应最大池化、平均池化和卷积操作的反过来使用。1、插值法；2、反池化；3、反卷积。

缩小图像（或称为下采样（`subsampled`）或降采样（`downsampled`））的主要目的有两个：1、使得图像符合显示区域的大小；2、生成对应图像的缩略图。

下采样定义：对于一个样值序列间隔几个样值取样一次，这样得到新序列就是原序列的下采样。

下采样就是抽取，是多速率信号处理中的基本内容之一。

下采样用池化层也可以用卷积，把卷积的步长设为2一般就可以缩小一倍了。比如`YOLOv3`中用的`Darknet-53`

## 1.1 上采样

### 1.1.1 上采样MovingLeastSquares



```c++
class  pcl::MovingLeastSquares< PointInT, PointOutT >
```

官网描述：

```
	MovingLeastSquares represent an implementation of the MLS (Moving Least Squares) algorithm for data smoothing and improved normal estimation.

	It also contains methods for upsampling the resulting cloud based on the parametric fit. Reference paper: "Computing and Rendering Point Set Surfaces" by Marc Alexa, Johannes Behr, Daniel Cohen-Or, Shachar Fleishman, David Levin and Claudio T. Silva www.sci.utah.edu/~shachar/Publications/crpss.pdf

	Note
    There is a parallelized version of the processing step, using the OpenMP standard. Compared to the standard version, an overhead is incurred in terms of runtime and memory usage. The upsampling methods DISTINCT_CLOUD and VOXEL_GRID_DILATION are not parallelized completely, i.e. parts of the algorithm run on a single thread only. 
```





## 1.2 下采样



### 1.2.1 体素重心下采样VoxelGrid

#### 1.2.1.1 体素质心的计算

体素质心下采样的原理很简单，首先将点云进行体素划分，然后计算非空体素的质心代替该体素内的所有点，实现点云的下采样。

已知一个非空体素V，其中包含m个点，则该体素的质心P<sub>centroid</sub>(x<sub>centroid</sub>，y<sub>centroid</sub>，z<sub>centroid</sub>)为：
$$
\begin{cases}
x_{centroid} = \frac{\sum_{i=1}^{m}{x_i}}{m}\\
y_{centroid} = \frac{\sum_{i=1}^{m}{y_i}}{m}\\
z_{centroid} = \frac{\sum_{i=1}^{m}{z_i}}{m}
\end{cases}
$$


#### 1.2.1.2 pcl库函数

```c++
class  pcl::VoxelGrid< PointT >
class  pcl::VoxelGrid< pcl::PCLPointCloud2 >
```

官网的描述:

```
	VoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data
	The VoxelGrid class creates a 3D voxel grid (think about a voxel grid as a set of tiny 3D boxes in space) over the input point cloud data. Then, in each voxel (i.e., 3D box), all the points present will be approximated (i.e., downsampled) with their centroid. This approach is a bit slower than approximating them with the center of the voxel, but it represents the underlying surface more accurately.
```

比较适合对海量的点云在处理前进行数据压缩，而且可以在特征提取等处理中选择合适的体素（voxel）大小等参数，提高算法效率。该函数对输入的点云数据创建一个三维体素栅格，每个体素内用体素中所有点的重心来近似显示体素中其他点，这样该体素内所有点都用一个重心点最终表示。用每个体素重心近似代替体素中的其他点。这种方法比用体素中心来逼近的方法更慢，但它对于采样点对应曲面的表示更为准确。

它的优点是可以在下采样的时候保存点云的形状特征。

<font color = red>这种方法有几个缺点：</font>

- <font color = red>与使用体素中心和近似体素重心下采样相比，它需要更长的处理时间；</font>
- <font color = red>它对嘈杂的输入空间敏感；</font>
- <font color = red>它不能准确地表示下垫面（underlying surface）</font>

所需头文件为：

```c++
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/impl/voxel_grid.hpp>
```

代码实现：

```c++
    cout << "->正在体素下采样..." << endl;
    pcl::VoxelGrid<pcl::PointXYZ> downSampled;  //创建滤波对象
    downSampled.setInputCloud (cloud);            //设置需要过滤的点云给滤波对象
    downSampled.setLeafSize (0.05f, 0.05f, 0.05f);  //设置滤波时创建的体素体积为5cm的立方体，三个参数表示体素栅格叶大小，分别表示体素在XYZ方向的尺寸
    downSampled.setDownsampleAllData(false);     //设置是否对所有的字段进行下采样
    downSampled.filter (*cloud_filtered);           //执行滤波处理，存储输出
```

`setDownsampleAllData`的意思是：点云有不同的类型，比如 `PointXYZ`，有的是`PointXYZRGB`，还有其他类型，也就是一个点包含多种不同信息，比如空间位置`XYZ`，颜色信息`RGB`，或者强度信息等，如果想要对所有信息（字段）下采样则设置为`true`，只对`XYZ`下采样的话设置为`false`。下采样结果如下图所示。

![](assets/VoxelGrid-tp.png)

![](assets/VoxelGrid.png)

#### 1.2.1.3 手写代码实现

代码分为三部分：

+ main.cpp

+ voxel_centroid_down_sampling.h

+ voxel_centroid_down_sampling.cpp

   

<font color = red>`main.cpp`</font>

```c++
#include "voxel_centroid_down_sampling.h"
#include <pcl/console/time.h>

int main()
{
	//----------------------------- 加载点云 -----------------------------
	pcl::PointCloud<PointT>::Ptr cloud_in(new pcl::PointCloud<PointT>);
	if (pcl::io::loadPCDFile("grid.pcd", *cloud_in) < 0)
	{
		PCL_ERROR("/a->点云文件不存在！/n");
		system("pause");
		abort();
	}
	cout << "->共加载 " << cloud_in->points.size() << " 个数据点" << endl;
	//===================================================================

	pcl::console::TicToc time;
	time.tic();
	//------------------------- 三维体素格网化点云 ------------------------
	pcl::PointCloud<PointT>::Ptr cloud_downSample(new pcl::PointCloud<PointT>);
	VoxelCentriodDownSample vcds;		//创建三维体素格网化对象
	vcds.setInputCloud(cloud_in);		//设置输入点云
	vcds.setGridStep(0.2);				//设置体素格网边长
	vcds.downSample(cloud_downSample);	//执行体素质心下采样，并将采样结果保存到cloud_downSample中

	cout << "->体素质心下采样用时：" << time.toc() / 1000 << " s" << endl;
	//===================================================================

	//------------------------- 保存体素质心下采样点云 ------------------------
	if (!cloud_downSample->empty())
	{
		pcl::io::savePCDFileASCII("downSample_centroid.pcd", *cloud_downSample);
		cout << "->下采样点云的点数为：" << cloud_downSample->points.size() << endl;
	}
	else
	{
		PCL_ERROR("\a->下采样点云为空！\n");
		system("pause");
	}
	//===================================================================
	
	return 0;
}
```

输出结果为：

```c++
->共加载 5746 个数据点
->体素质心下采样用时：0.243 s
->下采样点云的点数为：856
```

<font color = red> `voxel_centroid_down_sampling.h`</font>

```c++
#pragma once
#include <pcl/io/pcd_io.h>
#include <pcl/common/common.h>

using namespace std;

typedef pcl::PointXYZ PointT;

//体素质心下采样类
class VoxelCentriodDownSample
{
public:
	/**
	* @brief   ：设置输入点云
	* @param[I]：cloud_in（输入点云）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setInputCloud(pcl::PointCloud<PointT>::Ptr cloud_in);

	/**
	* @brief   ：设置体素格网边长
	* @param[I]：step（体素格网边长）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setGridStep(double step);

	/**
	* @brief   ：体素下采样
	* @param[I]：none
	* @param[O]：downSampleCloud（下采样点云）
	* @return  : none
	* @note    ：
	**/
	void downSample(pcl::PointCloud<PointT>::Ptr downSampleCloud);

private:
	pcl::PointCloud<PointT>::Ptr m_cloud_in;	//输入点云
	bool is_setInputCloud = false;

	double m_step;		//格网边长
	bool is_setGridStep = false;

	int m_row;			//格网总行数
	int m_col;			//格网总列数
	int m_lay;			//格网总层数

};
```

<font color = red> `voxel_centroid_down_sampling.cpp`</font>

```c++
#include "voxel_centroid_down_sampling.h"


/**
* @brief   ：设置输入点云
* @param[I]：cloud_in（输入点云）
* @param[O]：none
* @return  : none
* @note    ：
**/
void VoxelCentriodDownSample::setInputCloud(pcl::PointCloud<PointT>::Ptr cloud_in)
{
	m_cloud_in = cloud_in;
	is_setInputCloud = true;
}

/**
* @brief   ：设置体素格网边长
* @param[I]：step（体素格网边长）
* @param[O]：none
* @return  : none
* @note    ：
**/
void VoxelCentriodDownSample::setGridStep(double step)
{
	if (step > 0)
	{
		m_step = step;
		is_setGridStep = true;
	}
	else
	{
		PCL_ERROR("\a->格网边长应为正数！\n");
		system("pause");
		abort();
	}
}

/**
* @brief   ：体素质心下采样
* @param[I]：none
* @param[O]：downSampleCloud（下采样点云）
* @return  : none
* @note    ：
**/
void VoxelCentriodDownSample::downSample(pcl::PointCloud<PointT>::Ptr downSampleCloud)
{
	if (!is_setGridStep)
	{
		PCL_ERROR("\a->请先设置格网边长！\n");
		system("pause");
		abort();
	}
	pcl::PointXYZ min;
	pcl::PointXYZ max;
	pcl::getMinMax3D(*m_cloud_in, min, max);

	m_row = (int)((max.y - min.y) / m_step) + 1;
	m_col = (int)((max.x - min.x) / m_step) + 1;
	m_lay = (int)((max.z - min.z) / m_step) + 1;

	int row_i;			//每一点的行号，从1开始
	int col_i;			//每一点的列号，从1开始
	int lay_i;		//每一点的层号，从1开始
	int grid_id_pt;		//逐行对应的一维格网编号id，从1开始
	multimap<int, PointT> m_grid3D;	//存放水平面格网点云的容器

	//遍历点云，进行三维体素格网化
	size_t num_cp = m_cloud_in->points.size();
	for (size_t i = 0; i < num_cp; i++)
	{
		row_i = (int)((m_cloud_in->points[i].y - min.y) / m_step) + 1;	//每一点的行号，从1开始
		col_i = (int)((m_cloud_in->points[i].x - min.x) / m_step) + 1;	//每一点的列号，从1开始
		lay_i = (int)((m_cloud_in->points[i].z - min.z) / m_step) + 1;//每一点的列号，从1开始

		grid_id_pt = (lay_i - 1) * (m_row * m_col) + (row_i - 1) * m_col + col_i;	//格网一维索引，从1开始
		m_grid3D.insert(pair<int, PointT>(grid_id_pt, m_cloud_in->points[i]));		//将每一个id对应的点坐标存入容器grids3D中
	}

	//判断体素是否为空，若非空，则计算体素内点云质心，以质心代替该体素内的所有点
	for (int lay = 1; lay <= m_lay; lay++)			//层扫描
	{
		for (int row = 1; row <= m_row; row++)		//行扫描
		{
			for (int col = 1; col <= m_col; col++)	//列扫描
			{
				int grid_id;	//逐行对应的一维格网编号id，从1开始
				grid_id = (lay - 1) * (m_row * m_col) + (row - 1) * m_col + col;
				if (m_grid3D.count(grid_id))		//若体素格网内有点，则计算体素质心
				{
					float sum_x, sum_y, sum_z;
					sum_x = sum_y = sum_z = 0;

					auto range = m_grid3D.equal_range(grid_id);
					for(auto it = range.first;it!=range.second; ++it)
					{
						sum_x += (*it).second.x;
						sum_y += (*it).second.y;
						sum_z += (*it).second.z;
					}

					PointT temp;	//临时存放体素质心
					temp.x = sum_x / m_grid3D.count(grid_id);
					temp.y = sum_y / m_grid3D.count(grid_id);
					temp.z = sum_z / m_grid3D.count(grid_id);

					downSampleCloud->push_back(temp);
				}
			}
		}
	}
}
```

#### 1.2.1.4 pcl库函数同手写代码对比

```shell
->加载了 5746 个数据点
->正在进行体素下采样...
->体素下采样用时：0.058 s
->下采样点云的点数为：836
```



<center>下采样结果对比</center>

| 方法           | 用时   | 点数 |
| -------------- | ------ | ---- |
| pcl::VoxelGrid | 0.058s | 836  |
| 手写代码       | 0.243s | 856  |



### 1.2.2 近似体素重心下采样ApproximateVoxelGrid

`ApproximateVoxelGrid`近似体素滤波企图以 **更快的速度** 实现与`VoxelGrid` 体素滤波相同的下采样，它通过 [**散列函数**（Hashing Function）](https://zhuanlan.zhihu.com/p/49435564)**快速逼近质心**，而不是精细确定质心并对点云进行下采样。采样结果是近似逼近的体素质心，并不是体素中心。

```c++
class  pcl::ApproximateVoxelGrid< PointT >
```

官网的描述:

```
	ApproximateVoxelGrid assembles a local 3D grid over a given PointCloud, and downsamples + filters the data. 
```

所需头文件为：

```c++
#include <pcl/filters/approximate_voxel_grid.h>
#include <pcl/filters/impl/voxel_grid_occlusion_estimation.hpp>
```

代码实现：

```c++
	cout << "->正在进行近似体素重心下采样..." << endl;
	pcl::ApproximateVoxelGrid<pcl::PointXYZ> avg;	//创建滤波器对象
	avg.setInputCloud(cloud);						//设置待滤波点云
	avg.setLeafSize(0.05f, 0.05f, 0.05f);			//设置滤波时创建的体素体积为5cm的立方体，三个参数表示体素栅格叶大小，分别表示体素在XYZ方向的尺寸
	avg.setDownsampleAllData(false);				//如果只有XYZ字段，则设置为false，如果对所有字段，如intensity，都进行下采样，则设置为true
	avg.filter(*cloud_filtered);							//执行下采样，保存结果于cloud_sub
```

`setDownsampleAllData`的意思是：点云有不同的类型，比如 `PointXYZ`，有的是`PointXYZRGB`，还有其他类型，也就是一个点包含多种不同信息，比如空间位置`XYZ`，颜色信息`RGB`，或者强度信息等，如果想要对所有信息（字段）下采样则设置为`true`，只对`XYZ`下采样的话设置为`false`。下采样结果如下图所示。

![](assets/ApproximateVoxelGrid-tp.png)

![](assets/ApproximateVoxelGrid.png)

**近似体素下采样** 比 **体素下采样** 获取的下采样点数多，且耗时短。

### 1.2.3 VoxelGridOcclusionEstimation



```c++
class  pcl::VoxelGridOcclusionEstimation< PointT >
```

官网的描述：

```
	VoxelGrid to estimate occluded space in the scene.
	The ray traversal algorithm is implemented by the work of 'John Amanatides and Andrew Woo, A Fast Voxel Traversal Algorithm for Ray Tracing'
```

所需头文件为：

```c++
#include <pcl/filters/voxel_grid_occlusion_estimation.h>
#include <pcl/filters/impl/voxel_grid_occlusion_estimation.hpp>
```





### 1.2.4 随机下采样RandomSample

首先指定要下采样的点数，然后随机进行采样。

```c++
class  pcl::RandomSample< PointT >
class  pcl::RandomSample< pcl::PCLPointCloud2 >
```

官网的描述:

```
	RandomSample applies a random sampling with uniform probability.//均等概率

	Based off Algorithm A from the paper "Faster Methods for Random Sampling" by Jeffrey Scott Vitter. The algorithm runs in O(N) and results in sorted indices http://www.ittc.ku.edu/~jsv/Papers/Vit84.sampling.pdf 
```

所需头文件为：

```c++
#include <pcl/filters/random_sample.h>
#include <pcl/filters/impl/random_sample.hpp>
```

代码实现：

```c++
	cout << "->正在进行RandomSample..." << endl;
	pcl::RandomSample<pcl::PointXYZ> rs;	//创建滤波器对象
	rs.setInputCloud(cloud);				//设置待滤波点云
	rs.setSample(2939);					//设置下采样点云的点数,同ApproximateVoxelGrid对比，设置2939个点
	//rs.setSeed(1);						//设置随机函数种子点
	rs.filter(*cloud_filtered);					//执行下采样滤波，保存滤波结果于cloud_sub
```

采样结果如下图所示。

![](assets/RandomSample-tp.png)

![](assets/RandomSample.png)

在相同的采样点数下，随机下采样比近似体素下采样耗时短，但是采样结果丧失了一部分点云的形状特征。

### 1.2.5 均匀下采样UniformSampling 

#### 1.2.5.1 体素中心的计算

首先将点云进行体素划分，然后计算非空体素的中心代替该体素内的所有点，实现点云的下采样。

已知一个点的行列层数(row, col, lay)，体素边长step，坐标最小值x<sub>min</sub>、y<sub>min</sub>、 z<sub>min</sub>，则该点所在体素的中心P<sub>center</sub>(x<sub>center</sub>，y<sub>center</sub>，z<sub>center</sub>)为：
$$
\begin{cases}
x_{center} = x_{min} + (col - 0.5) * step \\
y_{center} = y_{min} + (row - 0.5) * step \\
z_{center} = z_{min} + (lay - 0.5) * step
\end{cases}
$$




#### 1.2.5.2 pcl库函数

对点云数据创建一个三维体素栅格，然后，在每个体素保留一个最接近体素中心的点，代替体素中所有点。

```c++
class  pcl::UniformSampling< PointT >
```

官网的描述:

```
	UniformSampling assembles a local 3D grid over a given PointCloud, and downsamples + filters the data.

	The UniformSampling class creates a 3D voxel grid (think about a voxel grid as a set of tiny 3D boxes in space) over the input point cloud data. Then, in each voxel (i.e., 3D box), all the points present will be approximated (i.e., downsampled) with the closest point to the center of the voxel.
```

所需头文件为：

```c++
#include <pcl/filters/uniform_sampling.h>
#include <pcl/filters/impl/uniform_sampling.hpp>
```

代码实现：

```c++
	cout << "->正在进行UniformSampling..." << endl;
	pcl::UniformSampling<pcl::PointXYZ> us;		//创建滤波器对象
	us.setInputCloud(cloud);				//设置待滤波点云
	us.setRadiusSearch(0.045f);				//设置滤波球半径
	us.filter(*cloud_filtered);				//执行滤波，保存滤波结果于cloud_filtered
```

采样结果如下图所示。

![](assets/UniformSampling-tp.png)



![](assets/UniformSampling.png)

采样点数差不多条件下，`UniformSampling`比`ApproximateVoxelGrid`耗时长，且丢失了部分点云形状。

#### 1.2.5.3 手写代码实现

代码分为三部分：

+ main.cpp
+ voxel_center_down_sampling.h
+ voxel_center_down_sampling.cpp

<font color = red> `main.cpp`</font>

```c++
#include "voxel_center_down_sampling.h"
#include <pcl/console/time.h>

int main()
{
	//----------------------------- 加载点云 -----------------------------
	pcl::PointCloud<PointT>::Ptr cloud_in(new pcl::PointCloud<PointT>);
	if (pcl::io::loadPCDFile("grid.pcd", *cloud_in) < 0)
	{
		PCL_ERROR("/a->点云文件不存在！/n");
		system("pause");
		abort();
	}
	cout << "->共加载 " << cloud_in->points.size() << " 个数据点" << endl;
	//===================================================================

	pcl::console::TicToc time;
	time.tic();
	//------------------------- 体素中心下采样点云 ------------------------
	pcl::PointCloud<PointT>::Ptr cloud_downSample(new pcl::PointCloud<PointT>);
	VoxelCenterDownSample vcds;
	vcds.setInputCloud(cloud_in);
	vcds.setGridStep(0.2);
	vcds.downSample(cloud_downSample);
	
	cout << "->体素中心下采样用时：" << time.toc() / 1000 << " s" << endl;
	//===================================================================

	//------------------------- 保存体素下采样点云 ------------------------
	if (!cloud_downSample->empty())
	{
		pcl::io::savePCDFileASCII("downSample_center.pcd", *cloud_downSample);
		cout << "->下采样点云的点数为：" << cloud_downSample->points.size() << endl;
	}
	else
	{
		PCL_ERROR("\a->下采样点云为空！\n");
		system("pause");
	}
	//===================================================================

	return 0;
}
```

<font color = red>`voxel_center_down_sampling.h`</font>

```c++
#pragma once
#include <pcl/io/pcd_io.h>
#include <pcl/common/common.h>

using namespace std;

typedef pcl::PointXYZ PointT;

//体素中心下采样类
class VoxelCenterDownSample
{
public:
	/**
	* @brief   ：设置输入点云
	* @param[I]：cloud_in（输入点云）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setInputCloud(pcl::PointCloud<PointT>::Ptr cloud_in);

	/**
	* @brief   ：设置体素格网边长
	* @param[I]：step（体素格网边长）
	* @param[O]：none
	* @return  : none
	* @note    ：
	**/
	void setGridStep(double step);

	/**
	* @brief   ：体素中心下采样
	* @param[I]：none
	* @param[O]：downSampleCloud（下采样点云）
	* @return  : none
	* @note    ：
	**/
	void downSample(pcl::PointCloud<PointT>::Ptr downSampleCloud);

private:
	pcl::PointCloud<PointT>::Ptr m_cloud_in;	//输入点云
	bool is_setInputCloud = false;

	double m_step;		//格网边长
	bool is_setGridStep = false;

	int m_row;			//格网总行数
	int m_col;			//格网总列数
	int m_lay;			//格网总层数

};
```

<font color = red>`voxel_center_down_sampling.cpp`</font>

```c++
#include "voxel_center_down_sampling.h"

/**
* @brief   ：设置输入点云
* @param[I]：cloud_in（输入点云）
* @param[O]：none
* @return  : none
* @note    ：
**/
void VoxelCenterDownSample::setInputCloud(pcl::PointCloud<PointT>::Ptr cloud_in)
{
	m_cloud_in = cloud_in;
	is_setInputCloud = true;
}

/**
* @brief   ：设置体素格网边长
* @param[I]：step（体素格网边长）
* @param[O]：none
* @return  : none
* @note    ：
**/
void VoxelCenterDownSample::setGridStep(double step)
{
	if (step > 0)
	{
		m_step = step;
		is_setGridStep = true;
	}
	else
	{
		PCL_ERROR("\a->格网边长应为正数！\n");
		system("pause");
		abort();
	}
}

/**
* @brief   ：体素中心下采样
* @param[I]：none
* @param[O]：downSampleCloud（下采样点云）
* @return  : none
* @note    ：
**/
void VoxelCenterDownSample::downSample(pcl::PointCloud<PointT>::Ptr downSampleCloud)
{
	if (!is_setGridStep)
	{
		PCL_ERROR("\a->请先设置格网边长！\n");
		system("pause");
		abort();
	}
	pcl::PointXYZ min;
	pcl::PointXYZ max;
	pcl::getMinMax3D(*m_cloud_in, min, max);

	m_row = (int)((max.y - min.y) / m_step) + 1;
	m_col = (int)((max.x - min.x) / m_step) + 1;
	m_lay = (int)((max.z - min.z) / m_step) + 1;

	int row_i;			//每一点的行号，从1开始
	int col_i;			//每一点的列号，从1开始
	int lay_i;		//每一点的层号，从1开始
	int grid_id_pt;		//逐行对应的一维格网编号id，从1开始
	multimap<int, PointT> m_grid3D;	//存放水平面格网点云的容器

	//遍历点云，进行三维体素格网化
	size_t num_cp = m_cloud_in->points.size();
	for (size_t i = 0; i < num_cp; i++)
	{
		row_i = (int)((m_cloud_in->points[i].y - min.y) / m_step) + 1;	//每一点的行号，从1开始
		col_i = (int)((m_cloud_in->points[i].x - min.x) / m_step) + 1;	//每一点的列号，从1开始
		lay_i = (int)((m_cloud_in->points[i].z - min.z) / m_step) + 1;//每一点的列号，从1开始

		grid_id_pt = (lay_i - 1) * (m_row * m_col) + (row_i - 1) * m_col + col_i;	//格网一维索引，从1开始
		m_grid3D.insert(pair<int, PointT>(grid_id_pt, m_cloud_in->points[i]));		//将每一个id对应的点坐标存入容器grids3D中
	}

	//判断体素是否为空，若非空，则计算体素内点云中心，以中心代替该体素内的所有点
	for (int lay = 1; lay <= m_lay; lay++)			//层扫描
	{
		for (int row = 1; row <= m_row; row++)		//行扫描
		{
			for (int col = 1; col <= m_col; col++)	//列扫描
			{
				int grid_id;	//逐行对应的一维格网编号id，从1开始
				grid_id = (lay - 1) * (m_row * m_col) + (row - 1) * m_col + col;
				
				//若体素格网内有点，则计算体素中心
				if (m_grid3D.count(grid_id))		
				{
					PointT temp;
					temp.x = min.x + (col - 0.5)*m_step;
					temp.y = min.y + (row - 0.5)*m_step;
					temp.z = min.z + (lay -0.5)*m_step;

					downSampleCloud->push_back(temp);
				}
			}
		}
	}
}
```

#### 1.2.5.4 体素质心同体素中心对比

```shell
->共加载 5746 个数据点
->体素中心下采样用时：0.201 s
->下采样点云的点数为：856
```

<center> 下采样结果对比</center>

| 方法     | 用时   | 点数 |
| -------- | ------ | ---- |
| 体素质心 | 0.243s | 856  |
| 体素中心 | 0.201s | 856  |

+ 体素质心下采样方法虽然耗时长，但采样结果更加准确；体素中心下采样方法耗时短，但容易失真。
+ 体素质心下采样和体素中心下采样，.h文件是一样的，只是下采样实现的方式(.cpp)不同。
+ 注意下面的代码，行列层都是从1开始，并非0。因此for循环的判断条件是"<="，并非“=”。

```c++
for (int lay = 1; lay <= m_lay; lay++)				//层扫描
	{
		for (int row = 1; row <= m_row; row++)		//行扫描
		{
			for (int col = 1; col <= m_col; col++)	//列扫描
			{
				···
			}
		}
	}
```



### 1.2.6 SamplingSurfaceNormal

SamplingSurfaceNormal将输入空间划分为多个网格，直到每个网格最多包含N个点，并在每个网格中随机采样点。 使用每个网格的N个点计算法线。 在网格内采样的所有点都分配有相同的法线。
作者：Aravindhan K Krishnan。
此代码从libpointmatcher（https://github.com/ethz-asl/libpointmatcher）分组过滤器中移植

```c++
class  pcl::SamplingSurfaceNormal< PointT >
```

官网的描述:

```
	SamplingSurfaceNormal divides the input space into grids until each grid contains a maximum of N points, and samples points randomly within each grid.
	Normal is computed using the N points of each grid. All points sampled within a grid are assigned the same normal.
	Author
    Aravindhan K Krishnan. This code is ported from libpointmatcher (https://github.com/ethz-asl/libpointmatcher) 
```

所需头文件为：

```c++
#include <pcl/filters/sampling_surface_normal.h>
#include <pcl/filters/impl/sampling_surface_normal.hpp>
```

代码实现：

```c++
#include<pcl/point_types.h>
#include<pcl/point_cloud.h>
#include<pcl/kdtree/kdtree_flann.h>
#include<pcl/kdtree/io.h>
#include<vector>
#include <pcl/features/normal_3d_omp.h>

	pcl::PointCloud<pcl::Normal>				cloud_normals;
	pcl::PointCloud<pcl::PointNormal>		cloud_point_normals;
	pcl::PointCloud<pcl::PointNormal>       Temp_cloud_point_normals;

	//NormalEstimationOMP使用OpenMP标准并行估计每个3D点的局部表面属性，例如表面法线和曲率。
	pcl::NormalEstimationOMP<pcl::PointXYZ, pcl::Normal> normalEstimation;
    normalEstimation.setRadiusSearch(0.02);
    normalEstimation.setNumberOfThreads(12);
    pcl::search::KdTree<pcl::PointXYZ>::Ptr kdtree(new pcl::search::KdTree<pcl::PointXYZ>);
    normalEstimation.setSearchMethod(kdtree);
    normalEstimation.setInputCloud(cloud);    //cloud是一个指针
	normalEstimation.compute(cloud_normals);

    clock_t start_ms = clock();
	cout << "->正在进行SamplingSurfaceNormal..." << endl;

	pcl::concatenateFields(*cloud, cloud_normals, cloud_point_normals);//SamplingSurfaceNormal处理的点云
	
	pcl::SamplingSurfaceNormal<pcl::PointNormal> ssn;		//创建滤波器对象
	ssn.setInputCloud(cloud_point_normals.makeShared());
    ssn.setSeed(1);    //Set seed of random function.设置随机函数的种子。
    ssn.setSample(2);  //Set maximum number of samples in each grid 设置每个网格中的最大样本数
    ssn.setRatio(0.1);  //Set ratio of points to be sampled in each grid设置每个网格中要采样的点的比例,比率越大点越多
    ssn.filter(Temp_cloud_point_normals);

	cloud_filtered->resize(Temp_cloud_point_normals.size());
    for (size_t i = 0; i < Temp_cloud_point_normals.size(); i++)//显示关键点把XYZ另存
    {
        cloud_filtered->points[i].x = Temp_cloud_point_normals.points[i].x;
        cloud_filtered->points[i].y = Temp_cloud_point_normals.points[i].y;
        cloud_filtered->points[i].z = Temp_cloud_point_normals.points[i].z;
    }
```

采样结果如下图所示。

![](assets/SamplingSurfaceNormal-tp.png)



![](assets/SamplingSurfaceNormal.png)





# 2、去除点云的离群点

## 2.1、双边滤波BilateralFilter

官网描述为：

```
A bilateral filter implementation for point cloud data.
```

`BilateralFilter`是对双边滤波算法在点云上的实现，该类的实现利用的并非`XYZ`字段的数据进行，而是利用强度数据进行双边滤波算法的实现，所以在使用该类时点云的类型必须有强度字段，否则无法进行双边滤波处理（所以在用这个函数的时候是需要注意自己输入点云的数据格式的，需要包含点云的强度信息）

```c++
pcl::BilateralFilter< PointT >
```

所需头文件为：

```c++
#include <pcl/filters/bilateral.h>
```

代码实现为：

```c++
// 双边滤波
pcl::search::KdTree<pcl::PointXYZI>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZI>);
pcl::BilateralFilter<pcl::PointXYZI> bf;
bf.setInputCloud(cloud);
bf.setSearchMethod(tree);
bf.setHalfSize(0.1);	// 设置高斯双边滤波窗口的一半大小,即搜索半径。
bf.setStdDev(0.03);		// 设置标准差参数
bf.filter(*outcloud);
```



## 2.2、统计滤波器**StatisticalOutlierRemoval** 

基于统计学去噪，先求取全局点云距离分布，然后依次判断每个采样点与其邻域的距离是否满足阈值。

[pcl::StatisticalOutlierRemoval< PointT >](https://pointclouds.org/documentation/classpcl_1_1_statistical_outlier_removal.html)

[pcl::StatisticalOutlierRemoval< pcl::PCLPointCloud2 >](https://pointclouds.org/documentation/classpcl_1_1_statistical_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html)





## 2.3、半径滤波器**RadiusOutlierRemoval**

基于密度的去噪,判断当前点的邻域点数，过小则将其视为噪音点

[pcl::RadiusOutlierRemoval< PointT >](https://pointclouds.org/documentation/classpcl_1_1_radius_outlier_removal.html)

[pcl::RadiusOutlierRemoval< pcl::PCLPointCloud2 >](https://pointclouds.org/documentation/classpcl_1_1_radius_outlier_removal_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html)



## 2.4、模型滤波器ModelOutlierRemoval 



## 2.4、基于点云频率的滤波方法



# 3、点云空间裁剪

## 3.1 直通滤波器**PassThrough** 

直通滤波去噪,在 X、Y、Z 方向设置阈值对点云进行截取（快速去除离群点用）

[pcl::PassThrough< PointT >](https://pointclouds.org/documentation/classpcl_1_1_pass_through.html)

[pcl::PassThrough< pcl::PCLPointCloud2 >](https://pointclouds.org/documentation/classpcl_1_1_pass_through_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html)



```c++
        cloud_origin_->clear();
        ptfilter_.setInputCloud(cloud);
        ptfilter_.setFilterFieldName("intensity");
        ptfilter_.setFilterLimits(240, 255);
        ptfilter_.setNegative(false);
        ptfilter_.filter(*cloud_filtered);
```





## 3.2 条件滤波器ConditionRemoval 



## 3.3 滤波器CropHull



## 3.4  滤波器CropBox

[pcl::CropBox< PointT >](https://pointclouds.org/documentation/classpcl_1_1_crop_box.html)

[pcl::CropBox< pcl::PCLPointCloud2 >](https://pointclouds.org/documentation/classpcl_1_1_crop_box_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html)

## 3.5 滤波器BoxClipper3D



## 3.6 滤波Clipper3D





# 4、 提取指定范围内的点云

## 4.1 索引提取ExtractIndices 

[pcl::ExtractIndices< PointT >](https://pointclouds.org/documentation/classpcl_1_1_extract_indices.html)

[pcl::ExtractIndices< pcl::PCLPointCloud2 >](https://pointclouds.org/documentation/classpcl_1_1_extract_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html)





# 5、 平滑点云数据密度



## 5.1 高斯滤波GaussianKernel

[pcl::filters::Convolution< PointIn, PointOut >](https://pointclouds.org/documentation/classpcl_1_1filters_1_1_convolution.html)

[pcl::filters::ConvolvingKernel< PointInT, PointOutT >](https://pointclouds.org/documentation/classpcl_1_1filters_1_1_convolving_kernel.html)

[pcl::filters::GaussianKernelRGB< PointInT, PointOutT >](https://pointclouds.org/documentation/classpcl_1_1filters_1_1_gaussian_kernel_r_g_b.html)



[pcl::experimental::advanced::FunctorFilter< PointT, FunctionObject >](https://pointclouds.org/documentation/classpcl_1_1experimental_1_1advanced_1_1_functor_filter.html)

[pcl::Filter< PointT >](https://pointclouds.org/documentation/classpcl_1_1_filter.html)

[pcl::Filter< pcl::PCLPointCloud2 >](https://pointclouds.org/documentation/classpcl_1_1_filter_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html)



[pcl::FilterIndices< PointT >](https://pointclouds.org/documentation/classpcl_1_1_filter_indices.html)

[pcl::FilterIndices< pcl::PCLPointCloud2 >](https://pointclouds.org/documentation/classpcl_1_1_filter_indices_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html)

[pcl::FrustumCulling< PointT >](https://pointclouds.org/documentation/classpcl_1_1_frustum_culling.html)

[pcl::GridMinimum< PointT >](https://pointclouds.org/documentation/classpcl_1_1_grid_minimum.html)

[pcl::LocalMaximum< PointT >](https://pointclouds.org/documentation/classpcl_1_1_local_maximum.html)

[pcl::MedianFilter< PointT >](https://pointclouds.org/documentation/classpcl_1_1_median_filter.html)

[pcl::NormalRefinement< NormalT >](https://pointclouds.org/documentation/classpcl_1_1_normal_refinement.html)

[pcl::NormalSpaceSampling< PointT, NormalT >](https://pointclouds.org/documentation/classpcl_1_1_normal_space_sampling.html)



[pcl::PlaneClipper3D< PointT >](https://pointclouds.org/documentation/classpcl_1_1_plane_clipper3_d.html)

[pcl::ProjectInliers< PointT >](https://pointclouds.org/documentation/classpcl_1_1_project_inliers.html)

[pcl::ProjectInliers< pcl::PCLPointCloud2 >](https://pointclouds.org/documentation/classpcl_1_1_project_inliers_3_01pcl_1_1_p_c_l_point_cloud2_01_4.html)



[pcl::ShadowPoints< PointT, NormalT >](https://pointclouds.org/documentation/classpcl_1_1_shadow_points.html)

# 6、去除点云Nan数据

void [pcl::removeNaNFromPointCloud](https://pointclouds.org/documentation/group__filters.html#ga9de762e05951938f074479c3bf8ae084) (const [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) > &cloud_in, [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) > &cloud_out, [Indices](https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6) &index)



void [pcl::removeNaNNormalsFromPointCloud](https://pointclouds.org/documentation/group__filters.html#ga8156e210186174a05af6251a2932006a) (const [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) > &cloud_in, [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) > &cloud_out, [Indices](https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6) &index)



void [pcl::removeNaNFromPointCloud](https://pointclouds.org/documentation/group__filters.html#ga0839c52ff34eb1f6ffc58cf5cc853bd8) (const [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) > &cloud_in, [Indices](https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6) &index)

 # 7、其他

void [pcl::applyMorphologicalOperator](https://pointclouds.org/documentation/group__filters.html#gab8ec453347225d3a0d34c70e0a9ee223) (const typename [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) >::ConstPtr &cloud_in, float resolution, const int morphological_operator, [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) > &cloud_out)



std::vector<float> [pcl::assignNormalWeights](https://pointclouds.org/documentation/group__filters.html#ga2fa1a673ddb4fce5d408141a0f7f10ec) (const [PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [NormalT](https://pointclouds.org/documentation/structpcl_1_1_normal.html) > &cloud, [index_t](https://pointclouds.org/documentation/namespacepcl.html#a45edbae979af563e6a1e39fd1aad3911) index, const [Indices](https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6) &k_indices, const std::vector< float > &k_sqr_distances)



bool [pcl::refineNormal](https://pointclouds.org/documentation/group__filters.html#ga97a19f59a33da441d2e7ba35506627ad) (const [PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [NormalT](https://pointclouds.org/documentation/structpcl_1_1_normal.html) > &cloud, int index, const [Indices](https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6) &k_indices, const std::vector< float > &k_sqr_distances, [NormalT](https://pointclouds.org/documentation/structpcl_1_1_normal.html) &point)



Eigen::MatrixXi [pcl::getHalfNeighborCellIndices](https://pointclouds.org/documentation/group__filters.html#gaffa333cb2c210067835f11bf84feb659) ()

Eigen::MatrixXi  [pcl::getAllNeighborCellIndices](https://pointclouds.org/documentation/group__filters.html#ga6a35c2d72627c558cb22b85d1f2c0679) ()

void [pcl::getMinMax3D](https://pointclouds.org/documentation/group__filters.html#gaaff287f132f05316c896e410d689569b) (const typename [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) >::ConstPtr &cloud, const std::string &distance_field_name,  float min_distance, float max_distance, Eigen::Vector4f &min_pt,  Eigen::Vector4f &max_pt, bool limit_negative=false)



void [pcl::getMinMax3D](https://pointclouds.org/documentation/group__filters.html#ga11cf5b99837ee9ed5e5e85e87f12c075) (const typename [pcl::PointCloud](https://pointclouds.org/documentation/classpcl_1_1_point_cloud.html)< [PointT](https://pointclouds.org/documentation/structpcl_1_1_point_x_y_z_r_g_b.html) >::ConstPtr &cloud, const [Indices](https://pointclouds.org/documentation/namespacepcl.html#a8bfe09b8680e7129dd0fd6177c1a2ce6) &indices, const std::string &distance_field_name, float  min_distance, float max_distance, Eigen::Vector4f &min_pt,  Eigen::Vector4f &max_pt, bool limit_negative=false)







## 基于密度的去噪



## 直通滤波去噪



## 4、手动去燥



- 人机交互框选不感兴趣点云并删除

## 5、基于假设检验的粗差剔除



- 假设点云数据仅在一个维度上存在误差，则对每一点利用其邻域点的属性值对其进行拟合，并求取拟合后的值与原始属性的差值。根据偶然误差服从正态分布的特性，通过设定一个置信区间，将误差值较大的点视为噪音点或失真点进行剔除

## 6、基于横切分层剔除噪音



- 这里通过对点云的高程 进行横切分层，然后，统计每个分割区域内的点云数量， 将分割区内小于一定阈值的点作为粗差予以清除

## 7、基于点到平面距离去噪



- 通过判断邻近点云数据的拟合平面，将离拟合平面距离值为负的点云看作噪声点云数据

## 8、移动平滑法



- 通过移动平滑法与二次多项式拟合曲面的方法去除噪声

## 9、中值滤波去噪



- 详见中值滤波





# 参考：

1、[官网](https://pointclouds.org/documentation/group__filters.html)

2、《点云库PCL从入门到精通》郭浩

3、[PCL：点云滤波汇总：算法原理 + 代码实现](https://blog.csdn.net/weixin_46098577/article/details/114385690)

4、[PCL点云滤波去噪](https://blog.csdn.net/qq_30815237/article/details/86294496)

5、[PCL点云数据处理基础目录](https://blog.csdn.net/weixin_46098577/article/details/119972670?spm=1001.2014.3001.5501)

6、[PCL源码分析-pcl/filter/sampling_surface_normal.h](https://blog.csdn.net/qq_34792438/article/details/114363189)

7、[点云三维体素格网的建立❤️原理与实现](https://blog.csdn.net/weixin_46098577/article/details/120973463?spm=1001.2014.3001.5501)

8、[点云二维格网的建立❤️原理与实现](https://blog.csdn.net/weixin_46098577/article/details/120965652?spm=1001.2014.3001.5501)

